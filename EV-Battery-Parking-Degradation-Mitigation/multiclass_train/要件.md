# 放置場所予測（多クラス・横展開）Codex 指示書｜MVP＋α

> 前提：**hashvin ごとに完全独立**で学習・評価する。  
> 目的：充電直後の**最初の長時間放置（6h以上）**の放置クラスタ（HEAD K≤10＋OTHER）を **Top-1** で当てる。  
> アプローチ：**多クラス分類（softmax）**。クラス依存特徴は **横展開**（Cjごとに列化）。  
> 特徴量は「少数精鋭」を徹底（MVP＋α）。`time_compat_Cj` は **中央値遅延×4hビン**の軽量近似を採用。

---

## 0. ポリシー（重要）

1) **hashvin完全独立**  
   - 入力、集計、ヘッド抽出、学習、評価、分布推定のすべてを **単一hashvinのデータのみ**で実施する。  
   - 他のhashvinの情報は一切使用しない。

2) **リーク防止の厳守**  
   - ヘッド（HEAD）抽出、頻度（freq）、Recency（recency_h）、時間分布（p_start）、遅延中央値（L̃）は **学習期間（train）のみ**で作る。  
   - 推論・評価では **学習期間で固定した辞書**を使う。  
   - 時系列Split（charge_end_time昇順）で **train/valid/test** を分割し、「未来の情報」を学習側に混ぜない。

3) **Kの上限**  
   - HEADは **K≤10** に制限し、それ以外は **OTHER** にマージ。列の爆発と長尾ノイズを抑える。

4) **MVP＋α哲学**  
   - まずは **距離／頻度／Recency／簡易time_compat** の4本柱＋最小限の共通特徴のみ。  
   - 効果が薄い列は削る・増やさない。運用で安定したら段階的に拡張。

5) **評価の透明性**  
   - Overall Top-1（Strict/Head-only）と **クラス別Recall** を必ず出す。  
   - 誤推奨コストに応じて Top-1@τ（Coverage/Accuracy）を運用検討。

---

## 1. 入力データ（前提）

### 1.1 入力①：イベント一覧（既存加工）
- `hashvin, session_cluster(-1はノイズ), session_type(inactive/charge), start_time, end_time, start_soc, end_soc, start_lat, start_lon, end_lat, end_lon, duration_minutes`  
- 20分未満の放置、充電後に移動なしの放置、走行セッションは **除去済み**。

### 1.2 入力②：充電→最初の6h以上放置（既存加工）
- `hashvin`
- `charge_cluster, charge_start_time, charge_end_time, charge_start_soc, charge_end_soc, charge_lat, charge_lon, charge_durations_minutes`
- `next_long_inactive_cluster`（なければ欠損＝本モデルの教師対象外）
- `inactive_start_time, inactive_end_time, inactive_lat, inactive_lon, inactive_time_minutes`

**本モデルの教師対象**：`next_long_inactive_cluster` が **存在する行のみ**（“長時間放置なし”検知はスコープ外）。

---

## 2. 時系列分割（hashvin内）

- `charge_end_time` 昇順で **train/valid/test = 80/10/10%（目安）**。  
- 以降のすべての統計・辞書は **trainのみ**で作成・固定。

---

## 3. ヘッド（HEAD K≤10）抽出

**目的**：充電直後の長時間放置先として **実効性の高いクラスタ**を優先採用。データが薄い場合は「日常長居地」で補完。

1) **第一優先（充電直後6h放置の実績ベース）**  
   - 指標A：`count_long_inactive_after_charge`（充電直後にCjで6h放置した件数）  
   - 指標B：`total_long_inactive_hours_after_charge`（合計時間[h]）  
   - 並び順：A降順 → B降順

2) **補完（K不足時／日常長居地から）**  
   - 指標C：`count_long_inactive_anytime`（充電条件なしの6h放置件数）  
   - 指標D：`total_long_inactive_hours_anytime`（合計時間[h]）  
   - 並び順：C降順 → D降順  
   - 抽出条件：`session_type == inactive` かつ `duration_minutes >= 360`（6時間以上）のセッションのみ対象

3) 上位**K≤10** を **HEAD**、残りは **OTHER**。  
4) **教師**：真値がHEAD内ならそのID、外ならOTHER。

**必要性**：  
- 充電直後ベースは「今回のタスク（充電→長居）」に **直接的**。  
- データが薄いhashvinでも、日常長居地で **HOME/WORKの周期性** を拾える。  
- K制限で列爆発と長尾ノイズを抑止。

---

## 4. 特徴量（MVP＋α）

> **クラス非依存（共通）**と **クラス依存（横展開）** に分ける。  
> クラス依存は **Cjごとに同じ4本**を作り、合計 **4×K列**。最小で強い構成。

### 4.1 共通特徴（各セッション1行）

1) **時間・曜日（充電開始時刻ベース）**  
   - `time_feature_mode` で表現を切替：  
     - `cyclic`（デフォルト）: `dow = charge_start_time.weekday()`、`hour_sin` / `hour_cos = sin/cos(2πh/24)`  
     - `datetime`: `charge_start_time`（tz付き）とその UNIX 秒をそのまま渡す  
     - `categorical`: 2時間帯カテゴリ（`00_02`, `02_04`, …）と曜日カテゴリ（`mon`〜`sun`）  
     - `all`: 上記すべてを付与  
   **理由**：充電イベントが「いつ」発生したかで行動が変わるため。sin/cosにより周期性を滑らかに表現しつつ、木系モデルではカテゴリ表現も試せるようにしている。

2) **充電メタ**  
   - `station_type`（200V/急速のOne-Hot）  
   - `soc_start`（充電開始時点のSOC）  
   **リーク対策**：`charge_end_time` / `charge_durations_minutes` / `charge_end_soc` / `soc_delta` など「完了後にしか分からない値」は学習から除外し、充電開始時点で利用可能な情報に限定する。

3) **（任意の＋α）行動フェーズの粗信号**  
   - `is_return_band`（18–24時）／`is_commute_band`（7–10または9–18の業務帯）／`weekend_flag`  
   **必要性**：粗い0/1で**帰宅/出勤のフェーズ**を表す低コスト特徴。効果が薄ければ全削除可。

4) **直前長時間放置から充電地点への移動ベクトル**  
   - `prev_to_charge_distance_m`, `prev_to_charge_delta_lat_m`, `prev_to_charge_delta_lon_m` をメートル単位で記録。  
   **必要性**：直前の放置場所からどれだけ移動して充電しているかで「帰宅途中なのか／これから遠出するのか」を推定できる。
   **設定**：当日行動ヒストグラムは `day_time_bin_hours` でビン幅を、`day_time_window_mode`（`rolling` or `calendar`）と `day_time_window_hours` で集計範囲を切り替え可能。

> *注*：`prev_drive_km/min` が安定に取れるなら追加可（「直前に長距離→帰宅志向」など）。

---

### 4.2 クラス依存特徴（Cjごと：MVP 4本）

> すべて **trainのみ** の履歴から作成。推論・評価では固定辞書を参照。

1) **距離** `dist_to_Cj`  
   - **計算**：充電地点（`charge_lat, charge_lon`）と Cj重心（train内の中位/平均座標）のハバーサイン距離を計算し、メートル換算して整数化（例：`km × 1000` を四捨五入）。  
   - **必要性**：**近い場所ほど次の放置候補になりやすい**という強い物理的制約を直接表現。最重要。

2) **頻度** `freq_hashvin_Cj`  
   - **計算**：学習期間において **「充電直後の6h放置」**で Cj を選んだ **累積回数**（その時点まで）。  
     データ希薄時はラプラス平滑（+1）など軽微に。  
   - **必要性**：**個体の習慣性**（HOME/WORKの繰返し）を即物的に反映。距離と組合わせると安定化。

3) **Recency** `recency_Cj_h`  
   - **計算**：直近で Cj を選んだ時刻からの **経過時間[h]**。未訪問は一定の大値（例：1e6）で埋める。  
   - **必要性**：**再訪周期**（例えば毎平日に職場、毎晩自宅）を捉える。頻度と非線形に補完。

4) **時間相性（簡易版）** `time_compat_Cj`（**中央値遅延 × 4hビン**）  
   - **クラスタ側分布 p_start_Cj**：  
     - 対象：**充電条件を外した**「全6h以上の放置開始」  
     - 集計：`dow × 4h_bin（0–4,4–8,…,20–24）` の **42ビン** でカウント  
     - 平滑：ラプラス（+α, α=1推奨）→ **確率** `p_start_Cj[d,b]`  
     - *意味*：Cj は **どの曜日×時間帯に“長居を始めやすいか”** の経験則
   - **遅延の中央値 L̃**：  
     - 対象：**充電開始**→**長時間放置開始**までの遅延[h]（充電＋寄り道を含む）  
     - 集計：train内で中央値 **L̃** を算出（hashvin共通／十分ならCj別）。  
     - *意味*：充電から長居開始までの**代表的シフト量**
   - **到着ビンの推定**：  
     - 現セッションの `charge_start_time` を **L̃** だけ前進させ、`(dow, 4h_bin)` を一つ決定（曜日跨ぎは円環）。  
   - **スコア化**：  
     - `time_compat_Cj = p_start_Cj[到着(d,b)]` を基本とし、隣接ビンを0.5重みで加算して近傍補間。  
     - 0〜1の確率値として扱い、充電時刻＋遅延後の時間帯における「長居開始しやすさ」を表す。  
   - **必要性**：HOME（夜間）／WORK（平日昼）の**強い周期**を、**遅延（充電時間＋寄り道）**を織り込んで簡単かつ安定に反映。  
   - **採用理由**：分布畳み込みより**軽量・実装容易・データ希薄に強い**。MVPに最適。

5) **前回長時間放置クラスタからの遷移確率** `transition_from_prev_to_Cj`  
   - **計算**：train期間の `prev_long_inactive_cluster` と `charge_start_time`（曜日×時間帯）から `next_long_inactive_cluster` への遷移を集計し、ラプラス平滑して確率化。  
   - **必要性**：平日朝に職場から充電したら次は自宅…といった日常ルートを直接特徴化し、候補クラスタの優先度を引き上げる。  
   - **補足**：遷移データが乏しい場合は全体分布（GLOBAL）や一様分布にフォールバックする。

---

## 5. 特徴量テーブル（学習用DF）

- **行**：充電セッション（`next_long_inactive_cluster` が存在するセッションのみ）  
- **キー**：`session_id, hashvin, charge_end_time`  
- **共通列**：§4.1  
- **クラス別列**（C1..CK）：各Cjごとに  
  - `dist_to_Cj, freq_hashvin_Cj, recency_Cj_h, time_compat_Cj`  
- **目的変数**：`y_class ∈ {C1,…,CK, OTHER}`（真値がHEAD外ならOTHER）

---

## 6. 学習（AutoMLの要件のみ記載）

- **問題種別**：multiclass（softmax）。  
- **評価指標**：`accuracy`（Top-1と整合）。  
- **分割**：hashvin内の **train/valid/test** を明示。  
- **重要度確認**：学習後に特徴重要度を確認し、効果の薄い列を次イテレーションで削除（MVP維持）。

---

## 7. 評価（レポート仕様）

**必須**  
1) **Top-1 Accuracy（Strict）**：OTHER含む全テスト。  
2) **Top-1 Accuracy（Head-only）**：真値がHEAD内のテストのみ。  
3) **クラス別Recall**（HEADクラスのみ）：  
   - 「真がCjのとき、CjをTop-1で当てた割合」。  
   - HOME/WORKの取りこぼし確認に必須。  
4) **混同行列（HEAD間）**：  
   - HOME↔WORKなど取り違いパターンを可視化。

**任意（運用判断用）**  
- **Top-1@τ**：`max確率 < τ` は「推奨なし（NONE）」  
  - `Coverage@τ`（推奨を出せた割合）  
  - `Accuracy@τ`（推奨を出した中の命中率）  
- 誤推奨コストが高い場合は **τを上げてAccuracy重視**（Coverage低下は許容）。

> Balanced Accuracy / Log Loss は本MVPでは不要。Top-1＋クラス別Recallで十分に品質判断可能。

---

## 8. 作成フロー（hashvin単位の実行順）

1) **時系列分割**：`charge_end_time` で train/valid/test。  
2) **HEAD抽出**（trainのみ）：A/B優先→不足はC/Dで補完→K≤10。  
3) **クラスタ重心**：train内のCj座標から中心点を確定。  
4) **辞書作成（trainのみ）**：  
   - `p_start_Cj[d,b]`（全6h放置の開始分布×42ビン、ラプラス平滑）  
   - `L̃`（充電開始→長時間放置開始の遅延中央値[h]）  
5) **特徴量付与**：  
   - 共通：§4.1  
   - クラス依存（各Cj）：距離（log1p推奨）／頻度（累積）／Recency（h、未訪問大値）／`time_compat_Cj`（L̃シフト→`p_start_Cj`参照、必要に応じ隣接ビン0.5）  
6) **教師作成**：真値がHEAD外はOTHERに置換。  
7) **学習＆評価**：§6, §7に従い実施。  
8) **重要度レビュー**：寄与の薄い列を削ぎ落とし、MVP列集合を固定化。

---

## 9. 設計判断の根拠（なぜこのMVPで効くのか）

- **距離**：物理的制約（近接優位）は最強の先験情報。`log1p`で遠距離の影響過大化を防ぐ。  
- **頻度**：個体の**習慣性**を直接表現。HOME/WORKの繰返しを確実に拾う。  
- **Recency**：**再訪周期**を補正。頻度だけでは見えない“最近の嗜好変化（引っ越し等）”の兆候を早めに捉える。  
- **簡易time_compat**：**曜日×時間帯**の強い周期を、**遅延（充電＋寄り道）**を織り込んで反映。  
  分布畳み込みより軽量で、データ希薄でも安定。  
- **K≤10**：列爆発と長尾ノイズを抑止し、**解釈性と安定性**を担保。  
- **Top-1＋クラス別Recall**：製品要件（Top-1重視）と運用安全（HOME/WORKの取りこぼし可視化）を両立。

---

## 10. 運用（ドリフト対応）

- **定期更新**：3–6ヶ月周期で **HEAD再抽出→再学習**（hashvin単位）。  
- **OTHER監視**：OTHER比率増加や、特定クラスタのクラス別Recall低下を検知したら、次サイクルでHEAD入替候補へ。  
- **拡張余地**：MVPで安定後、必要に応じ  
  - 到着分布×開始分布の**畳み込み版 time_compat**  
  - 滞在長分位（p50/p80）、転移確率、埋め込み  
  を段階的に追加（ただし列増やしすぎは厳禁）。

---
