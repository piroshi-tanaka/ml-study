# CodeX指示書 — EV放置場所予測（hashvin単位・AutoGluon・候補展開）

## 0. ゴール / 前提
- **目的**: 充電開始時点で「次に長時間放置（≥6h）するクラスタ」を **Top-k で予測**する。
- **単位**: **hashvin（ユーザー）ごと**に「前処理→統計推定→候補生成→特徴量生成→学習→評価」を独立実行。  
  他ユーザーの影響を**完全に排除**すること。
- **学習方式**: 「**候補展開 + バイナリ分類（AutoGluon Tabular）**」。  
  1充電イベント×K候補クラスタのK行を作成し、正解候補のみ `label=1`。予測時は確率降順でランキング。
- **データ優先度**: 充電以外の通常放置（ルーティン）も活用しつつ、**直近履歴**（デフォルト3か月）を**優先的に反映**。  
  ウィンドウ長や減衰率は**外部パラメータで変更可能**にする。

> **実装上の必須ルール**  
> - すべての関数・クラスに**日本語コメント**を記載（目的・入出力・例外・副作用・なぜ必要か）。  
> - 保守性: 型ヒント、関数分割、小さな純粋関数、設定値は `config` で一元管理、ログ出力と入力検証を実装。

---

## 1. 入力データと前処理（hashvinごと）

### 1.1 入力（1行=1セッション）
必須列:
- `hashvin, session_id, session_type[inactive/charging], session_cluster`
- `start_time, end_time, duration_minutes`
- `start_soc, end_soc, change_soc`
- `start_lat, start_lon, end_lat, end_lon`

前処理列（hashvinごとに付与）:
- `weekday = start_time.dayofweek`（0=Mon..6=Sun）
- `start_hour = start_time.hour`（0..23）
- `date = start_time.date`
- `is_long_park = (session_type=='inactive') & (duration_minutes>=360)`

**検証**: 時系列ソート、必須列の存在、NaNチェック。

---

## 2. 直近重み / 期間ウィンドウ（可変パラメータ）
- `window_days`（デフォルト: 90）… 統計推定に優先して使う期間（直近履歴）。  
- `halflife_days`（デフォルト: 30）… 時系列減衰の半減期。  
- `use_decay_weight: bool`（デフォルト: True）… 減衰使用ON/OFF。
- **時系列重み**: `weight_time = exp(- ln(2) * age_days / halflife_days)` を可変。  
  ※ `age_days = （基準日 - イベント発生日）日`

> 直近重み・ウィンドウ長は **config** から変更可能にすること。

---

## 3. 充電→長時間放置リンク（df_links）
**定義**: 各充電イベントの**終了～次の充電開始**の間に現れる**最初の**長時間放置（inactive & ≥6h）を1件だけリンク。該当なしは NA。

出力列:
- `hashvin, event_id`
- `weekday, charge_cluster, charge_start_time, charge_start_hour, charge_end_time`
- `park_cluster(NA), park_start_time(NA), park_start_hour(NA), park_duration_minutes(NA)`
- `gap_minutes(NA 可)`
- `dist_charge_to_park_km(任意)`
- `age_days, weight_time`（§2の定義）

**目的**: 充電後の“主要な長時間放置”を因果に近い形で抽出し、学習の正例に利用。

---

## 4. ルーティン統計（通常放置活用・hashvinごと）

### 4.1 存在確率（df_presence）— 滞在の「幅」を持つ地図
**定義**: 曜日 `w` × 時間 `h` に、クラスタ `c` で**長時間放置が存在**している割合。
- 各長時間放置イベントの区間 `[start_time, end_time)` と各1時間ビン `[h:00, h+1:00)` の**重なり分（分）**を算出。  
- **直近重み**を掛けて集計:  
  `W(c,w,h) = Σ( weight_time * overlap_minutes/60 )`
- **確率化（平滑 α）**:  
  `presence_prob(c|w,h) = (W(c,w,h)+α) / Σ_c'(W(c',w,h)+α)`

出力列:
- `hashvin, weekday, hour, cluster, presence_weight=W, presence_prob`

**目的**: 夜間自宅・日中職場など、**滞在の幅**を反映した24h×曜日の行動地図を得る。

---

### 4.2 開始確率（df_start）— 「始まりの山」
**定義**: 曜日 `w` × 時間 `h` に、クラスタ `c` で**長時間放置が始まる**割合。  
- `count_start(c,w,h) = Σ( weight_time * 1[start_hour=h & weekday=w & cluster=c] )`
- **確率化（平滑 α）**:
  `start_prob(c|w,h) = (count_start+α) / Σ_c'(count_start(c')+α)`

出力列:
- `hashvin, weekday, hour, cluster, start_count, start_prob`

**目的**: 「次の長時間放置」の**開始タイミング**を直接表す。

---

## 5. 充電拠点のバイアス（hashvinごと・直近優先）

### 5.1 放置先クラスタの条件付き確率（df_charge_prior）
**定義**: `(charge_cluster=cc, weekday=w, charge_start_hour=h_c)` 条件で **放置先クラスタ c** の確率。  
- `count_link(c | cc,w,h_c) = Σ weight_time * 1[リンクが (cc,w,h_c)→c]`
- **確率化（平滑 α）**:
  `P(park=c | cc,w,h_c) = (count_link+α)/Σ_c'(count_link(c')+α)`

出力列:
- `hashvin, charge_cluster, weekday, charge_start_hour, park_cluster, count, prob`

**目的**: 充電ステーション固有の「どこへ放置しやすいか」を時刻と曜日で捉える。

---

### 5.2 放置開始“時刻”の分布（df_hour_prior）
**定義**: `(cc,w,h_c)` 条件で **放置開始時刻 h_p** の分布。  
- df_links の `park_start_hour` から直近重みで集計→確率化。

出力列:
- `hashvin, charge_cluster, weekday, charge_start_hour, park_start_hour, count, prob`

**目的**: 充電後に**何時頃**から放置が始まりやすいかを把握。

---

## 6. クラスタ属性（df_cluster_profile）
- `long_park_ratio(c) = #long(c) / #all_park(c)`  
- `peak_hour(c)`：長時間放置**開始時刻**の円平均（24h）、`peak_hour_std(c)`：円分散  
- `center_lat, center_lon`：代表座標（平均/中央値）

出力列:
- `hashvin, cluster, long_park_ratio, peak_hour, peak_hour_std, center_lat, center_lon`

**目的**: 各クラスタの「性格」（夜型/昼型/安定性）と地理情報を特徴量に。

---

## 7. 候補集合の生成（イベントごと K 件）

### 7.1 可変パラメータ（候補生成）
- `K_candidates`（デフォルト: 12）  
- `M_routine`（滞在多い放置先の上位数、デフォルト: 8）  
- `N_charge_prior`（拠点由来の上位数、デフォルト: 8）  
- `L_nearby`（近傍候補数、デフォルト: 4）  
- `nearby_radius_km`（デフォルト: 1.0）  
- **重み**  
  - `w_routine`（ルーティン重み、デフォルト 1.0）  
  - `w_charge`（充電prior重み、デフォルト 1.0）  
  - `lambda_start`（開始確率の寄与、デフォルト 0.7）  
  - `gamma_distance`（距離減衰、デフォルト 0.05 / km）

> これらは **config** で変更可能にすること（実験容易化のため）。

### 7.2 生成ロジック
1) **滞在時間が多い放置先（ルーティン）**  
   - スコア `S_routine(c) = presence_prob(c|w,h_c) + lambda_start * start_prob(c|w,h_c)`  
   - 上位 `M_routine` を選抜（hashvin内でのみ）。
2) **過去この充電ステーションから放置した場所（充電prior）**  
   - `S_charge(c) = P(park=c | charge_cluster, w, h_c)`  
   - 上位 `N_charge_prior` を選抜。
3) **特別枠**  
   - **近傍クラスタ**: 充電拠点から `nearby_radius_km` 以内で長時間実績のあるクラスタ上位 `L_nearby`
4) **統合 → 重複除去 → 事前ランク → K 件に丸め**  
   - 総合スコア（事前ランク用）  
     ```
     S_pre(c) =
       [ 1 + w_routine * S_routine(c) ] *
       [ 1 + w_charge  * S_charge(c)  ] *
       exp( - gamma_distance * dist_km(charge_cluster, c) )
     ```

出力（df_candidates: 1イベントあたり K 行）:
- `hashvin, event_id, candidate_cluster, source_tag[routine/charge/near/homework], pre_score(S_pre), dist_km, is_home, is_work`

---

## 8. 学習テーブル（df_train_rows）— AutoGluon binary
**行定義**: 1充電イベント × K候補クラスタ。  
**目的変数**: 当該イベントの**実際の次の長時間放置クラスタ**なら `label=1`、それ以外 `0`。  
（リンクなしイベントは学習対象外で可）

### 8.1 特徴量（すべて“充電開始時点で利用可”）
**A. ルーティン（通常放置由来）**
- `presence_prob(c|w,h_c)` … §4.1 の確率
- `start_prob(c|w,h_c)` … §4.2 の確率
- `long_park_ratio(c)` … §6
- `peak_hour(c), peak_hour_std(c)` … §6
- `delta_to_peak = min(|h_c - peak_hour(c)|, 24 - |h_c - peak_hour(c)|)`  
  → **なぜ効く**: 候補の“得意時間”に充電時刻が近いほど選ばれやすい

**B. 充電コンテキスト（直近優先）**
- `charge_prior = P(park=c | charge_cluster, w, h_c)` … §5.1  
  → **なぜ効く**: ステーション固有の癖を反映
- `compat_time`（将来時刻整合）  
  - 定義: 充電後の「放置開始時刻」分布 `P(h_p | cc, w, h_c)` と `presence_prob(c|w,h)` の**前向き時間差カーネル**内積  
  - 前向き差 `Δh = (h - h_c) % 24`、カーネル `K(Δh; σ) = exp(-Δh^2 / (2σ^2))`（σは config）  
  - 計算: `compat_time(c) = Σ_h P(h | cc,w,h_c) * presence_prob(c|w,h) * K((h - h_c)%24; σ)`  
  → **なぜ効く**: 「充電後に起きがちな時刻」と「候補の得意時間」の相性

**C. 地理・SOC・直前文脈・周期**
- `dist_km(charge_cluster, c)`, `bearing`（haversine/atan2）  
  → **なぜ効く**: 物理的移動の実現性
- `start_soc, time_since_last_charge_min, soc_drop_since_prev`  
  → **なぜ効く**: 帰宅前充電/日中つなぎ充電の違いの手がかり
- `prev_cluster_id（充電直前）` と `flow_from_prev = P(c | prev_cluster, w, h_prev)`（任意）  
  → **なぜ効く**: 出勤中/帰宅中など**現在の文脈**を反映
- `sin/cos(2π*h_c/24)`, `sin/cos(2π*w/7)`  
  → **なぜ効く**: 24h/週の周期性を連続特徴に

**リーク防止**: `charge_end_time` 以降の情報（実際の放置内容など）は**使用禁止**。

### 8.2 df_train_rows スキーマ（例）
hashvin | event_id | candidate_cluster | label
weekday | charge_cluster | charge_start_hour
presence_prob | start_prob | long_park_ratio
peak_hour | peak_hour_std | delta_to_peak
charge_prior | compat_time
dist_km | bearing
start_soc | time_since_last_charge_min | soc_drop_since_prev
prev_cluster_id | flow_from_prev (optional)
sin_hour | cos_hour | sin_week | cos_week


---

## 9. 学習・推論・評価（hashvinごとに独立実行）
- **学習**: `TabularPredictor(problem_type='binary')`  
  - 乱数シード固定、学習ログ出力、入力件数・スパース率の警告
- **推論**: 同一 `event_id` の候補K件に `predict_proba` → **確率降順**でランキング（Top-k）
- **評価**: すべて**hashvinごと**に集計・報告  
  - **HitRate@k**（k=1,3,5）  
  - **NDCG@k**（上位正解重視）  
  - **MRR**
- **時系列分割**: train=過去 / val/test=未来。直近重み・windowは**訓練統計の推定にのみ**使用。

---

## 10. 実装API（関数I/O・日本語コメントを必須）

### 10.1 中間テーブル作成
- `build_links(df_sessions, config) -> df_links`
- `build_presence(df_sessions, config) -> df_presence`
- `build_start(df_sessions, config) -> df_start`
- `build_charge_prior(df_links, config) -> df_charge_prior`
- `build_hour_prior(df_links, config) -> df_hour_prior`
- `build_cluster_profile(df_sessions, config) -> df_cluster_profile`

### 10.2 候補生成（重み可変）
- `build_candidates_for_event(event_row, T_* , config) -> df_candidates`
  - 候補スコア `S_pre` は `w_routine, w_charge, lambda_start, gamma_distance` を **config** から参照

### 10.3 特徴量生成
- `make_training_rows_for_event(event_row, df_candidates, T_*, config) -> df_train_rows_event`

### 10.4 学習・推論・評価（hashvinごと）
- `train_user_model(df_train_rows_user, config) -> model`
- `predict_user_events(model, df_candidates_user, config) -> df_pred`
- `eval_user_predictions(df_pred, df_links_user, config) -> metrics`

> すべての関数に **日本語docstring** と **日本語コメント** を必ず付与。

---

## 11. 例外・バックオフ
- `df_charge_prior` がスパース: `w_charge=0` に自動降格し、ルーティン主体（`w_routine`）で候補選定。  
- 候補がK件に満たない: 近傍クラスタで補充（`nearby_radius_km` 拡大）  
- HOME/WORK は常に候補に含める（最低保証）

---

## 12. 代表的な落とし穴と回避
- **後ろ時間を“近い”と誤判定**: 時間差は必ず **前向き `(h - h_c) % 24`** で計算。  
- **リーク**: 充電後に生じる情報を特徴量に混ぜない。  
- **不均衡**: 目的変数 `label=1` はイベントあたり1行のみ。AutoGluonのクラス重み・早期打切りで安定化。  
- **過分割クラスタ**: 近接（例≤100m）をメタクラスタ化可能に。

---

## 13. 可変パラメータ一覧（configで管理）
window_days: 90
halflife_days: 30
use_decay_weight: true
alpha_smooth: 0.5
K_candidates: 12
M_routine: 8
N_charge_prior: 8
L_nearby: 4
nearby_radius_km: 1.0
lambda_start: 0.7
w_routine: 1.0
w_charge: 1.0
gamma_distance: 0.05
kernel_sigma_hour: 2.0 # compat_time のガウシアン幅
topk_eval: [1,3,5]


---

## 14. 期待される効果（なぜ効くか）
- **通常放置（ルーティン）**から24h×曜日の**存在**と**開始**の分布を高解像度で取得。  
- **直近3か月の充電→放置**でステーション固有の癖を**上書き補正**。  
- **距離・SOC・直前文脈・周期**で現実性と連続性を担保。  
→ 候補を**現実的かつ尤度の高い順**に並べ替えられ、Top-k 的中率が向上。

---
